// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: active_connections.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createActiveConnection = `-- name: CreateActiveConnection :one
INSERT INTO active_connections (
    display_name
    -- last_seen defaults to NOW()
    -- status defaults to 'lobby'
    -- current_room_id defaults to NULL
) VALUES (
    $1
)
RETURNING display_name, last_seen, status, current_room_id
`

// Registers a new active connection with a unique display name.
// Fails if the display_name is already taken (due to PRIMARY KEY constraint).
func (q *Queries) CreateActiveConnection(ctx context.Context, displayName string) (ActiveConnection, error) {
	row := q.db.QueryRow(ctx, createActiveConnection, displayName)
	var i ActiveConnection
	err := row.Scan(
		&i.DisplayName,
		&i.LastSeen,
		&i.Status,
		&i.CurrentRoomID,
	)
	return i, err
}

const deleteActiveConnection = `-- name: DeleteActiveConnection :exec
DELETE FROM active_connections
WHERE display_name = $1
`

// Removes an active connection record (e.g., on disconnect).
// ON DELETE CASCADE on players table will remove associated player records.
func (q *Queries) DeleteActiveConnection(ctx context.Context, displayName string) error {
	_, err := q.db.Exec(ctx, deleteActiveConnection, displayName)
	return err
}

const findStaleConnections = `-- name: FindStaleConnections :many
SELECT display_name FROM active_connections
WHERE last_seen < $1
`

// Finds connections that haven't been seen recently (for cleanup).
func (q *Queries) FindStaleConnections(ctx context.Context, lastSeen pgtype.Timestamptz) ([]string, error) {
	rows, err := q.db.Query(ctx, findStaleConnections, lastSeen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var display_name string
		if err := rows.Scan(&display_name); err != nil {
			return nil, err
		}
		items = append(items, display_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveConnection = `-- name: GetActiveConnection :one
SELECT display_name, last_seen, status, current_room_id FROM active_connections
WHERE display_name = $1
`

// Retrieves an active connection by display name.
func (q *Queries) GetActiveConnection(ctx context.Context, displayName string) (ActiveConnection, error) {
	row := q.db.QueryRow(ctx, getActiveConnection, displayName)
	var i ActiveConnection
	err := row.Scan(
		&i.DisplayName,
		&i.LastSeen,
		&i.Status,
		&i.CurrentRoomID,
	)
	return i, err
}

const listActiveConnections = `-- name: ListActiveConnections :many

SELECT
    ac.display_name,
    ac.status,
    r.game_type
FROM
    active_connections ac
LEFT JOIN
    rooms r ON ac.current_room_id = r.id
ORDER BY
    ac.last_seen DESC
`

type ListActiveConnectionsRow struct {
	DisplayName string      `json:"display_name"`
	Status      string      `json:"status"`
	GameType    pgtype.Text `json:"game_type"`
}

// $1 would be a timestamp like NOW() - INTERVAL '5 minutes'
// Lists all active connections with their status and game type.
func (q *Queries) ListActiveConnections(ctx context.Context) ([]ListActiveConnectionsRow, error) {
	rows, err := q.db.Query(ctx, listActiveConnections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveConnectionsRow
	for rows.Next() {
		var i ListActiveConnectionsRow
		if err := rows.Scan(&i.DisplayName, &i.Status, &i.GameType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveLobbyUsers = `-- name: ListActiveLobbyUsers :many
SELECT display_name FROM active_connections
WHERE status = 'lobby'
ORDER BY display_name
`

// Lists users currently in the lobby state.
func (q *Queries) ListActiveLobbyUsers(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listActiveLobbyUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var display_name string
		if err := rows.Scan(&display_name); err != nil {
			return nil, err
		}
		items = append(items, display_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActiveConnectionName = `-- name: UpdateActiveConnectionName :execrows
UPDATE active_connections
SET display_name = $1
WHERE display_name = $2
RETURNING display_name
`

type UpdateActiveConnectionNameParams struct {
	DisplayName   string `json:"display_name"`
	DisplayName_2 string `json:"display_name_2"`
}

func (q *Queries) UpdateActiveConnectionName(ctx context.Context, arg UpdateActiveConnectionNameParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateActiveConnectionName, arg.DisplayName, arg.DisplayName_2)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateConnectionLastSeen = `-- name: UpdateConnectionLastSeen :exec
UPDATE active_connections
SET last_seen = NOW()
WHERE display_name = $1
`

// Updates the last_seen timestamp for a connection (heartbeat).
func (q *Queries) UpdateConnectionLastSeen(ctx context.Context, displayName string) error {
	_, err := q.db.Exec(ctx, updateConnectionLastSeen, displayName)
	return err
}

const updateConnectionStatusAndRoom = `-- name: UpdateConnectionStatusAndRoom :one
UPDATE active_connections
SET
    status = $2,
    current_room_id = $3,
    last_seen = NOW()
WHERE
    display_name = $1
RETURNING display_name, last_seen, status, current_room_id
`

type UpdateConnectionStatusAndRoomParams struct {
	DisplayName   string      `json:"display_name"`
	Status        string      `json:"status"`
	CurrentRoomID pgtype.UUID `json:"current_room_id"`
}

// Updates the status and current_room_id for an active connection.
// e.g: when a player joins or leaves a room.
func (q *Queries) UpdateConnectionStatusAndRoom(ctx context.Context, arg UpdateConnectionStatusAndRoomParams) (ActiveConnection, error) {
	row := q.db.QueryRow(ctx, updateConnectionStatusAndRoom, arg.DisplayName, arg.Status, arg.CurrentRoomID)
	var i ActiveConnection
	err := row.Scan(
		&i.DisplayName,
		&i.LastSeen,
		&i.Status,
		&i.CurrentRoomID,
	)
	return i, err
}
